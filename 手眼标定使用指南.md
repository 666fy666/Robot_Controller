# 手眼标定使用指南

## 目录
1. [概述](#概述)
2. [手眼标定原理](#手眼标定原理)
3. [准备工作](#准备工作)
4. [详细操作步骤](#详细操作步骤)
5. [配置参数说明](#配置参数说明)
6. [标定结果验证](#标定结果验证)
7. [常见问题与故障排除](#常见问题与故障排除)
8. [标定结果的使用](#标定结果的使用)

---

## 概述

手眼标定（Hand-Eye Calibration）是机器人视觉系统中的关键步骤，用于确定相机坐标系与机器人末端执行器（夹爪/法兰）坐标系之间的变换关系。本项目实现的是**眼在手上（Eye-in-Hand）**标定，即相机安装在机器人末端执行器上。

### 标定目标

求解变换矩阵 **T_cam2gripper**，使得：
- 相机坐标系中的点可以通过该变换转换到夹爪坐标系
- 进而通过机器人正运动学转换到基坐标系
- 实现从图像坐标到机器人基坐标的完整转换链

### 标定流程概览

```
1. 准备标定板 → 2. 采集多组数据 → 3. 提取角点 → 4. 相机内参标定
    ↓
5. PnP解算 → 6. 数据清洗 → 7. 手眼标定求解 → 8. 结果验证与保存
```

---

## 手眼标定原理

### 坐标系关系

在手眼标定中，涉及以下坐标系：

- **基坐标系（Base）**：机器人基座坐标系
- **夹爪坐标系（Gripper）**：机器人末端执行器坐标系
- **相机坐标系（Camera）**：相机坐标系
- **标定板坐标系（Target）**：标定板坐标系

### 数学原理

手眼标定求解的是方程：**AX = XB**

其中：
- **A** = 夹爪相对变换（从位姿i到j）
- **X** = 待求的相机到夹爪变换（T_cam2gripper）
- **B** = 标定板相对变换（从位姿i到j）

通过采集多组不同位姿下的数据，构建超定方程组求解最优的 **X**。

### 支持的算法

本项目实现了三种经典算法，并自动选择最佳结果：

1. **Tsai算法**：经典方法，适用于大多数场景
2. **Park算法**：改进方法，在某些情况下精度更高
3. **Horaud算法**：另一种经典方法

---

## 准备工作

### 1. 硬件准备

#### 1.1 标定板要求

- **类型**：棋盘格标定板（Checkerboard）
- **内角点数**：11×8（行×列）
- **方格尺寸**：15mm × 15mm
- **材质**：建议使用硬质、平整的材料（如亚克力板、金属板）
- **打印质量**：确保黑白对比度高，边缘清晰

> **注意**：标定板参数必须与代码中的配置一致（见 `src/calibration/hand_eye_calibration.py`）

#### 1.2 相机要求

- **类型**：Intel RealSense相机（D435/D435i等）
- **安装**：固定在机器人末端执行器上
- **稳定性**：确保相机与夹爪之间无相对运动
- **清洁度**：保持镜头清洁，避免污渍影响图像质量

#### 1.3 机器人要求

- **通信**：支持RPC通信协议
- **精度**：机器人定位精度应满足标定要求
- **工作空间**：确保有足够的空间进行多角度拍摄

### 2. 软件准备

#### 2.1 环境检查

确保已安装以下依赖：

```bash
pip install opencv-python numpy scipy
```

#### 2.2 目录结构

确保项目目录结构如下：

```
eyeInHand/
├── src/
│   └── calibration/
│       └── hand_eye_calibration.py
├── images/              # 标定图片目录（需创建）
│   └── poses.txt        # 机器人位姿文件（需创建）
└── calibration/         # 标定结果目录（自动创建）
```

### 3. 环境准备

#### 3.1 光照条件

- **均匀光照**：避免强光直射和阴影
- **避免反光**：标定板表面不应有强烈反光
- **稳定光源**：使用稳定的光源，避免频闪

#### 3.2 标定板放置

- **固定位置**：标定板应固定在稳定位置
- **平整度**：确保标定板平整，无弯曲
- **可见性**：确保标定板在相机视野内清晰可见

---

## 详细操作步骤

### 步骤1：配置标定参数

打开 `src/calibration/hand_eye_calibration.py`，检查并修改配置区域（第12-32行）：

```python
# ================= 配置区域 =================
# 1. 标定板参数
CHECKERBOARD = (11, 8)  # 内角点 (行, 列)
SQUARE_SIZE = 15.0      # mm（方格尺寸）

# 2. 文件路径
IMAGE_DIR = './images'
POSE_FILE = './images/poses.txt'
CALIBRATION_DIR = './calibration'

# 3. 欧拉角顺序（与机器人一致）
CALIB_EULER_ORDER = 'xyz'  # 通常为 'xyz' 或 'zyx'

# 4. 优化阈值
MAX_PNP_ERROR = 0.5     # PnP重投影误差阈值(像素)
MIN_CALIB_IMAGES = 10    # 最少需要的图片数
RECALIBRATE_INTRINSICS = False  # 是否重新标定内参
SAVE_INDIVIDUAL_RESULTS = True  # 是否保存各方法结果
```

**重要说明**：
- `CHECKERBOARD` 和 `SQUARE_SIZE` 必须与实际标定板完全一致
- `CALIB_EULER_ORDER` 必须与机器人使用的欧拉角顺序一致
- `MIN_CALIB_IMAGES` 建议至少15张，更多数据可提高标定精度

### 步骤2：创建必要的目录

```bash
# 在项目根目录下执行
mkdir images
mkdir calibration
```

### 步骤3：采集标定数据

#### 3.1 机器人位姿规划

规划至少 **15组** 不同的机器人位姿，要求：

1. **位姿多样性**：
   - 覆盖不同的位置（前后、左右、上下）
   - 覆盖不同的姿态（不同的旋转角度）
   - 确保标定板在相机视野内清晰可见

2. **位姿间距**：
   - 相邻位姿之间应有明显的差异
   - 避免位姿过于接近（建议至少20mm位移或10°旋转）

3. **工作空间**：
   - 确保所有位姿都在机器人工作空间内
   - 避免奇异位形和碰撞

#### 3.2 采集图片

对于每个规划好的位姿：

1. **移动机器人到目标位姿**
   ```python
   # 示例：使用机器人控制程序移动到指定位姿
   robot.move_to_pose([x, y, z, rx, ry, rz])
   ```

2. **等待机器人稳定**
   - 等待至少1-2秒，确保机器人完全停止

3. **拍摄图片**
   - 使用相机拍摄彩色图像
   - 保存为 `images/1_Color.png`, `images/2_Color.png`, ...（按顺序编号）

4. **记录机器人位姿**
   - 读取当前机器人位姿（x, y, z, rx, ry, rz）
   - 记录到 `images/poses.txt` 文件中

#### 3.3 创建位姿文件

编辑 `images/poses.txt`，格式如下：

```
x1,y1,z1,rx1,ry1,rz1
x2,y2,z2,rx2,ry2,rz2
x3,y3,z3,rx3,ry3,rz3
...
```

**格式说明**：
- 每行一个位姿，对应一张图片
- 位姿顺序必须与图片编号顺序一致
- 坐标单位：位置（mm），角度（度）
- 使用逗号分隔，无空格

**示例**：
```
-381.853,-155.398,280.285,154.689,11.737,78.975
-370.367,-140.226,253.028,145.659,5.756,43.949
-421.629,-203.119,267.026,147.467,2.043,73.570
```

**注意事项**：
- 确保位姿文件中的行数与图片数量一致
- 如果某张图片未检测到角点，可以删除该行，但需要同时删除对应的图片
- 建议使用文本编辑器（如Notepad++）编辑，避免格式错误

### 步骤4：运行标定程序

#### 4.1 执行标定

在项目根目录下运行：

```bash
python -m src.calibration.hand_eye_calibration
```

或者：

```bash
cd src/calibration
python hand_eye_calibration.py
```

#### 4.2 标定过程说明

程序执行流程：

1. **读取位姿文件**
   ```
   [-] 读取机器人位姿: ./images/poses.txt
   ```

2. **提取角点**
   - 逐张显示图片，检测棋盘格角点
   - 按 `q` 或 `ESC` 键切换到下一张
   - 如果某张图片未检测到角点，会显示警告

3. **数据对齐**
   - 自动对齐图片和位姿数据
   - 显示有效数据组数

4. **相机内参标定**
   - 如果 `RECALIBRATE_INTRINSICS = False` 且存在已保存的内参，会加载已有内参
   - 否则重新标定内参
   - 显示标定质量评估

5. **PnP解算和数据清洗**
   - 使用PnP算法计算标定板位姿
   - 过滤重投影误差过大的数据
   - 显示保留的数据数量

6. **手眼标定求解**
   - 使用三种算法分别求解
   - 对比结果，选择最佳方法
   - 显示各方法的误差和质量指标

7. **结果验证和保存**
   - 验证标定结果
   - 保存到 `calibration/` 目录

### 步骤5：检查标定结果

#### 5.1 控制台输出

标定完成后，控制台会显示：

```
==================================================
【最终标定结果】
==================================================
最佳方法: Tsai
旋转矩阵 R_cam2gripper:
[[ 0.xxx  ...  ... ]
 [  ...  ...  ... ]
 [  ...  ...  ... ]]
平移向量 t_cam2gripper (mm):
[xx.xx  yy.yy  zz.zz]
==================================================
```

**关键指标检查**：

1. **相机-法兰距离**：
   ```
   相机-法兰距离: xxx.xx mm
   ```
   - 应与实际物理测量值大致相符（通常误差在10mm以内）
   - 如果差异过大，可能是标定数据有问题

2. **标定误差**：
   ```
   标定误差: x.xxxxxx
   ```
   - 越小越好，通常应 < 0.01
   - 如果误差过大，建议重新采集数据

3. **旋转矩阵质量**：
   ```
   旋转矩阵正交性误差: x.xxe-xx
   旋转矩阵行列式误差: x.xxe-xx
   ```
   - 正交性误差应接近0（< 1e-10）
   - 行列式应接近1（误差 < 1e-10）

#### 5.2 生成的文件

标定完成后，`calibration/` 目录下会生成：

1. **hand_eye_calibration.npz**（主文件）
   - 包含所有方法的标定结果
   - 包含相机内参
   - 包含最佳方法标识

2. **hand_eye_calibration_Tsai.npz**（如果 `SAVE_INDIVIDUAL_RESULTS = True`）
   - Tsai方法的结果

3. **hand_eye_calibration_Park.npz**
   - Park方法的结果

4. **hand_eye_calibration_Horaud.npz**
   - Horaud方法的结果

5. **camera_intrinsics.npz**
   - 相机内参和畸变系数

---

## 配置参数说明

### 标定板参数

| 参数 | 说明 | 默认值 | 修改建议 |
|------|------|--------|----------|
| `CHECKERBOARD` | 内角点数（行，列） | (11, 8) | 必须与实际标定板一致 |
| `SQUARE_SIZE` | 方格尺寸（mm） | 15.0 | 必须与实际标定板一致 |

### 文件路径配置

| 参数 | 说明 | 默认值 |
|------|------|--------|
| `IMAGE_DIR` | 标定图片目录 | `'./images'` |
| `POSE_FILE` | 位姿文件路径 | `'./images/poses.txt'` |
| `CALIBRATION_DIR` | 标定结果目录 | `'./calibration'` |

### 算法参数

| 参数 | 说明 | 默认值 | 建议值 |
|------|------|--------|--------|
| `CALIB_EULER_ORDER` | 欧拉角顺序 | `'xyz'` | 与机器人一致 |
| `MAX_PNP_ERROR` | PnP误差阈值（像素） | 0.5 | 0.3-0.8 |
| `MIN_CALIB_IMAGES` | 最少图片数 | 10 | 15-20 |
| `RECALIBRATE_INTRINSICS` | 是否重新标定内参 | False | 首次标定设为True |
| `SAVE_INDIVIDUAL_RESULTS` | 是否保存各方法结果 | True | 建议保持True |

### 参数调优建议

1. **提高标定精度**：
   - 增加 `MIN_CALIB_IMAGES` 到 20-30
   - 降低 `MAX_PNP_ERROR` 到 0.3
   - 采集更多样化的位姿数据

2. **加快标定速度**：
   - 设置 `RECALIBRATE_INTRINSICS = False`（使用已有内参）
   - 减少图片数量（但不低于10张）

3. **处理噪声数据**：
   - 提高 `MAX_PNP_ERROR` 到 0.8
   - 检查标定板质量和光照条件

---

## 标定结果验证

### 1. 物理验证

#### 1.1 距离验证

测量相机到机器人法兰的实际距离，与标定结果中的 `t_cam2gripper` 的模长对比：

```python
import numpy as np

# 加载标定结果
data = np.load('calibration/hand_eye_calibration.npz')
t_cam2g = data['t_cam2gripper']
distance = np.linalg.norm(t_cam2g)
print(f"标定得到的距离: {distance:.2f} mm")

# 与实际测量值对比
actual_distance = 150.0  # 实际测量值（mm）
error = abs(distance - actual_distance)
print(f"误差: {error:.2f} mm")
```

**判断标准**：
- 误差 < 10mm：优秀
- 误差 < 20mm：良好
- 误差 > 20mm：需要检查标定数据

#### 1.2 方向验证

检查旋转矩阵是否合理：

```python
R_cam2g = data['R_cam2gripper']

# 检查正交性
orthogonality_error = np.linalg.norm(R_cam2g @ R_cam2g.T - np.eye(3))
print(f"正交性误差: {orthogonality_error:.2e}")

# 检查行列式
det_error = abs(np.linalg.det(R_cam2g) - 1.0)
print(f"行列式误差: {det_error:.2e}")
```

**判断标准**：
- 正交性误差 < 1e-10：合格
- 行列式误差 < 1e-10：合格

### 2. 重投影验证

使用标定结果进行重投影，检查误差：

```python
import cv2
import numpy as np

# 加载标定结果
data = np.load('calibration/hand_eye_calibration.npz')
R_cam2g = data['R_cam2gripper']
t_cam2g = data['t_cam2gripper']
mtx = data['camera_matrix']
dist = data['dist_coeffs']

# 加载一组测试数据
# ... 使用实际数据进行验证
```

### 3. 实际应用验证

在实际抓取任务中验证标定精度：

1. **放置已知位置的物体**
2. **使用标定结果计算物体在基坐标系的位置**
3. **控制机器人移动到计算位置**
4. **检查实际位置误差**

**判断标准**：
- 位置误差 < 5mm：优秀
- 位置误差 < 10mm：良好
- 位置误差 > 10mm：需要重新标定

---

## 常见问题与故障排除

### 问题1：角点检测失败

**症状**：
```
[1/15] 1_Color.png: 未检测到角点
```

**可能原因**：
1. 标定板参数配置错误
2. 图片模糊或光照不足
3. 标定板未完全在视野内
4. 标定板反光或损坏

**解决方法**：
1. 检查 `CHECKERBOARD` 和 `SQUARE_SIZE` 配置
2. 改善光照条件，确保均匀照明
3. 调整机器人位姿，确保标定板完整可见
4. 更换标定板或使用无反光材料

### 问题2：PnP误差过大

**症状**：
```
剔除索引 5: PnP误差 1.234 > 阈值 0.5
```

**可能原因**：
1. 相机内参不准确
2. 标定板不平整
3. 图片质量差
4. 角点提取不准确

**解决方法**：
1. 重新标定相机内参（设置 `RECALIBRATE_INTRINSICS = True`）
2. 使用更平整的标定板
3. 重新拍摄清晰的图片
4. 检查角点检测结果，确保角点位置准确

### 问题3：有效数据不足

**症状**：
```
错误: 有效样本数太少 (<10)，无法进行标定。
```

**可能原因**：
1. 采集的图片数量不足
2. 大部分图片角点检测失败
3. 大部分数据被PnP过滤掉

**解决方法**：
1. 增加采集图片数量（建议至少20张）
2. 改善标定条件和图片质量
3. 适当提高 `MAX_PNP_ERROR` 阈值（但不建议超过1.0）

### 问题4：标定误差过大

**症状**：
```
标定误差: 0.123456
```

**可能原因**：
1. 位姿数据不准确
2. 位姿多样性不足
3. 机器人定位精度低
4. 数据对齐错误

**解决方法**：
1. 确保机器人位姿读取准确
2. 增加位姿多样性（不同位置、不同角度）
3. 检查机器人定位精度
4. 确保位姿文件与图片顺序一致

### 问题5：相机-法兰距离不合理

**症状**：
```
相机-法兰距离: 500.00 mm  # 但实际测量只有150mm
```

**可能原因**：
1. 坐标系定义错误
2. 位姿数据单位错误
3. 标定数据质量差

**解决方法**：
1. 检查坐标系定义（基坐标系、夹爪坐标系）
2. 确认位姿数据单位（位置：mm，角度：度）
3. 重新采集高质量的标定数据

### 问题6：标定结果不稳定

**症状**：
每次标定结果差异较大

**可能原因**：
1. 标定数据质量不一致
2. 机器人定位精度不稳定
3. 相机安装松动

**解决方法**：
1. 统一标定条件（光照、标定板位置）
2. 检查机器人定位精度
3. 确保相机固定牢固，无相对运动

### 问题7：内参加载失败

**症状**：
```
警告: 加载内参失败 (...)，将重新标定
```

**可能原因**：
1. 内参文件不存在
2. 内参文件损坏
3. 图像尺寸不匹配

**解决方法**：
1. 首次标定时会自动生成内参文件
2. 如果文件损坏，删除后重新标定
3. 确保使用相同分辨率的图像

---

## 标定结果的使用

### 1. 在检测配置中指定标定文件

编辑 `src/config/detection_config.py`：

```python
# 标定结果文件
CALIBRATION_DIR = './calibration'
CALIB_FILE = os.path.join(CALIBRATION_DIR, 'hand_eye_calibration_Horaud.npz')
# 或使用最佳结果
# CALIB_FILE = os.path.join(CALIBRATION_DIR, 'hand_eye_calibration.npz')
```

### 2. 加载标定结果

在代码中加载标定结果：

```python
import numpy as np

# 加载标定文件
calib_data = np.load('calibration/hand_eye_calibration.npz')

# 提取变换矩阵
R_cam2gripper = calib_data['R_cam2gripper']  # 旋转矩阵
t_cam2gripper = calib_data['t_cam2gripper']  # 平移向量

# 提取相机内参
camera_matrix = calib_data['camera_matrix']  # 内参矩阵
dist_coeffs = calib_data['dist_coeffs']      # 畸变系数
```

### 3. 坐标转换流程

完整的坐标转换链：

```
图像坐标 (u, v) 
    ↓ [相机内参 + 深度]
相机坐标系 (X_c, Y_c, Z_c)
    ↓ [T_cam2gripper]
夹爪坐标系 (X_g, Y_g, Z_g)
    ↓ [机器人正运动学]
基坐标系 (X_b, Y_b, Z_b)
```

### 4. 示例代码

```python
import numpy as np
import cv2

# 加载标定结果
calib_data = np.load('calibration/hand_eye_calibration.npz')
R_cam2g = calib_data['R_cam2gripper']
t_cam2g = calib_data['t_cam2gripper']
mtx = calib_data['camera_matrix']
dist = calib_data['dist_coeffs']

# 假设从图像中检测到物体中心 (u, v) 和深度 d
u, v = 320, 240  # 像素坐标
d = 0.5  # 深度（米）

# 1. 图像坐标转相机坐标
x_c = (u - mtx[0, 2]) * d / mtx[0, 0]
y_c = (v - mtx[1, 2]) * d / mtx[1, 1]
z_c = d
p_camera = np.array([[x_c], [y_c], [z_c]])

# 2. 相机坐标转夹爪坐标
p_gripper = R_cam2g @ p_camera + t_cam2g

# 3. 夹爪坐标转基坐标（需要机器人正运动学）
# p_base = robot_forward_kinematics(p_gripper, robot_joint_angles)
```

---

## 附录

### A. 标定板制作建议

1. **打印标定板**：
   - 使用高分辨率打印机（至少600 DPI）
   - 使用厚纸或硬质材料
   - 确保黑白对比度高

2. **固定标定板**：
   - 使用硬质背板（如亚克力板、金属板）
   - 确保标定板平整，无弯曲
   - 固定在稳定位置

3. **标定板尺寸计算**：
   - 内角点数：11×8
   - 方格数：10×7（内角点数-1）
   - 总尺寸：10×15mm × 7×15mm = 150mm × 105mm

### B. 位姿规划建议

1. **位置分布**：
   - 前后、左右、上下各方向都要覆盖
   - 避免所有位姿在同一平面

2. **角度分布**：
   - 绕X、Y、Z轴都要有旋转
   - 旋转角度范围：±30°到±180°

3. **位姿数量**：
   - 最少：15组
   - 推荐：20-30组
   - 最多：50组（超过50组收益递减）

### C. 标定质量评估标准

| 指标 | 优秀 | 良好 | 一般 | 较差 |
|------|------|------|------|------|
| 标定误差 | < 0.001 | < 0.01 | < 0.1 | ≥ 0.1 |
| 相机-法兰距离误差 | < 5mm | < 10mm | < 20mm | ≥ 20mm |
| 实际应用位置误差 | < 3mm | < 5mm | < 10mm | ≥ 10mm |
| 内参重投影误差 | < 0.1px | < 0.3px | < 0.5px | ≥ 0.5px |

### D. 参考资源

- OpenCV手眼标定文档：https://docs.opencv.org/
- 机器人坐标系转换：机器人学教材
- 相机标定原理：计算机视觉教材

---

## 更新日志

- **2026-01-27**：初始版本，完整的手眼标定使用指南

---