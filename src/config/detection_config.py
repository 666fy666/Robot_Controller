"""
检测相关配置模块
从 detect_and_grasp.py 提取的配置常量
"""
import numpy as np
import os

# ================= 标定配置区域 =================
# 1. 机器人的初始位姿（参考示教器读数）
ROBOT_INITIAL_POSE = [-222.449, -285.088, 334.716, -180.0, 0.0, 90.0]

# ===============================================
# 2. 工具/夹爪参数
# TOOL_LENGTH 表示工具或夹爪的长度（从法兰到夹爪尖端的距离），单位为毫米（mm）
TOOL_LENGTH = 235.0  # 典型的协作机器人夹爪长度约为235mm

# ===============================================
# 3.HOVER_HEIGHT 表示两阶段运动时，第一阶段悬停位置的z坐标相对于目标z坐标的偏移量，单位为毫米（mm）
# 正值表示悬停位置在目标位置上方，负值表示在下方
# 例如：如果目标z=100mm，HOVER_HEIGHT=50mm，则第一阶段悬停位置z=150mm
HOVER_HEIGHT = 50.0   # 悬停高度偏移，建议设置在30~100mm之间，确保安全悬停

# ===============================================
# 4.Z_OFFSET 表示夹爪末端距离检测表面时，末端位姿需要沿法线方向的额外偏移，单位为毫米（mm）
# 用于在末端执行器控制时，确保机器人"悬停"在目标上方以避免碰撞；如抓取时通常需要先下降再接触
Z_OFFSET = -8.0      # 根据实际工艺，通常设置在-20~-50mm之间，-30mm较为安全

# X_OFFSET 和 Y_OFFSET 表示末端位姿在局部坐标系x轴和y轴方向的额外偏移，单位为毫米（mm）
# 用于补偿预测坐标的系统误差，例如x轴预测偏大10mm时，可设置X_OFFSET = -10.0
X_OFFSET = -12.0     # x轴方向偏移补偿，负值表示减小x坐标
Y_OFFSET = 5.0       # y轴方向偏移补偿

# ===============================================
# 5. 机器人运动配置

# 坐标轴方向修正配置，用于调整输出的 x, y, z 三轴的符号，通常根据机器人/相机坐标系实际安装方向设定
# 例如如需翻转 z 轴方向，可设为 [1, 1, -1]
AXIS_SIGN = [1, 1, 1]  

# 欧拉角顺序定义。用于旋转矩阵与欧拉角的转换。'xyz' 表示先绕 x，再 y，再 z 轴旋转
DETECT_EULER_ORDER = 'xyz'  

# 是否启用法向估算功能。为 True 时将自动估算目标点处的法线角度及表面平面度，并用于末端姿态计算
ENABLE_NORMAL_ESTIMATION = True  

# 法向量估算邻域区域边长（单位：像素）。用于在邻域内采样点云以估算表面法线。值越大区域越大，法向更平滑但边缘鲁棒性变差
NORMAL_NEIGHBORHOOD_SIZE = 15  

# 计算法向量时需要的最小有效点数。如果邻域内有效点太少则认为法向估算不可靠
MIN_POINTS_FOR_NORMAL = 10  

# 深度邻域采样点的有效性阈值（单位：米）。采样点深度与中心点深度相差超过该值不参与法线估算，可有效滤除离群点
DEPTH_FILTER_THRESHOLD = 0.01  

# ===============================================
# 6. 顶面中心点选择（避免侧面干扰）
# 当物体（如正方体）倾斜时，颜色分割往往会把顶面+侧面合并成一个轮廓，
# 直接取轮廓重心会落在两个面之间。此处提供“在轮廓内部按深度选最近层”的策略：
# - 若能拿到 depth_frame：在最大轮廓内部取深度分布的近端分位数（默认5%）作为顶面深度，
#   并在该深度附近一个带宽内提取“顶面区域”，再对顶面区域计算重心作为抓取点。
# - 若深度不可用或顶面提取失败：回退到原始轮廓重心。
# 如果你觉得红点还会“偏向某一侧/某个角”
# 这通常表示：顶面 mask 只覆盖了“离相机更近”的一部分（深度带宽偏小），导致重心被拉偏。你可以按下面调参：
# 红点偏向近端（只取到半个顶面）：把 TOP_FACE_DEPTH_BAND_M 从 0.012 调到 0.018~0.025
# 红点偏向近端且蓝色不够完整：把 TOP_FACE_NEAR_PERCENTILE 从 5 调到 10~20
# 开始把侧面也吃进来（蓝色外扩到侧面）：反向把 TOP_FACE_DEPTH_BAND_M 或 TOP_FACE_NEAR_PERCENTILE 调小一点
ENABLE_TOP_FACE_CENTER = True

# 近端分位数（0~100），越小越偏向“最靠近相机”的表面
TOP_FACE_NEAR_PERCENTILE = 5

# 顶面深度带宽（单位：米）。越大越容易把侧面也包含进来；越小越容易漏检。
TOP_FACE_DEPTH_BAND_M = 0.014

# 顶面区域最小面积（像素），小于该面积则认为顶面提取失败并回退
TOP_FACE_MIN_AREA_PX = 200

# 若深度不可用/顶面深度提取失败，是否尝试纯2D的“内部分割线”方案
ENABLE_TOP_FACE_CENTER_2D_FALLBACK = True

# ===============================================
# 2D方案参数（在轮廓ROI内做 Canny + HoughLinesP 找顶面/侧面分割线）
TOP_FACE_2D_CANNY_T1 = 60
TOP_FACE_2D_CANNY_T2 = 160
TOP_FACE_2D_HOUGH_THRESHOLD = 50
TOP_FACE_2D_HOUGH_MIN_LINE_LEN_RATIO = 0.40  # 相对ROI尺寸的比例
TOP_FACE_2D_HOUGH_MAX_LINE_GAP = 10
TOP_FACE_2D_MIN_REGION_AREA_PX = 200

# ===============================================

# 7. 标定结果文件
CALIBRATION_DIR = './calibration'
CALIB_FILE = os.path.join(CALIBRATION_DIR, 'hand_eye_calibration_Horaud.npz')

# ===============================================
# 8. 多颜色 HSV 阈值配置
COLOR_RANGES = {
    'blue': (np.array([100, 120, 70]), np.array([130, 255, 255])),
    'red1': (np.array([0, 120, 70]), np.array([10, 255, 255])),
    'red2': (np.array([170, 120, 70]), np.array([180, 255, 255])),
    'green': (np.array([40, 60, 70]), np.array([85, 255, 255])),
    'yellow': (np.array([22, 120, 120]), np.array([35, 255, 255])),
    'orange': (np.array([10, 120, 120]), np.array([22, 255, 255])),
    'purple': (np.array([135, 60, 70]), np.array([165, 255, 255])),
}